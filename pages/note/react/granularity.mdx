import React, { useState, useEffect } from 'react'
import Exb from '../../../components/Exb'
import { Callout } from 'nextra-theme-docs'

# 细粒度更新

在典型的前端框架中，有一种细粒度的更新机制，细粒度更新实际上是在自动对以来进行追踪，以便在更新时只更新需要更新的部分。在 React 中，细粒度更新体现在 `useState` 以及 `useEffect` 中，当状态发生变化时，只会更新需要更新的部分，而不是整个组件。在 Vue 中，细粒度更新体现在 `watch` 以及 `computed` 中。

一个最为典型的例子如下：

```jsx
import React, { useState, useEffect } from 'react';

export function Example1(){
  const [count, setCount] = useState(0);
  useEffect(()=>{
    if (count > 10){
      setCount(0);
    }
  }, [count]);
  return (
    <div>
        {count}
        <button onClick={() => setCount(count + 1)}>+</button>
    </div>
  )
}
```

export function Example1 () {
  const [count, setCount] = useState(0)
  useEffect(() => {
    if (count > 10) {
      setCount(0)
    }
  }, [count])
  return (
    <div className={'flex h-max'}>
      {count}
      <button className={'ml-5 h-5 text-blue-500 flex items-center justify-center text-center text-2xl'} onClick={() => setCount(count + 1)}>+</button>
    </div>
  )
}

<Exb>
<Example1 />
</Exb>

在上面的例子中，我们使用 `useState` 和 `useEffect` 来实现一个计数器，当计数器的值大于 10 时，重置为 0。在这里副作用有一个依赖 `count`，当 `count` 发生变化时，副作用会重新执行。在这里，当 `count` 发生变化时，只有计数器的值发生了变化，而不是整个组件。那么让我们来实现一个简单的实例，实现细粒度更新。

## 订阅发布模式

在实现细粒度更新的过程中，我们需要实现一个订阅发布模式，订阅发布模式是一种设计模式，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。

发布订阅模式是一种定义对象间一对多的依赖关系的设计模式，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。在 JavaScript 中，发布订阅模式又被称为观察者模式。它可以广泛应用于异步编程中，这是一种替代传递回调函数的方案。比如，可以订阅 ajax 请求的 error、succ 等事件。无需过多关注对象在异步运行期间的内部状态，而只需要订阅感兴趣的事件发生点。

## `useState`

`useState` 用于存储一个状态，当这个状态发生变化时，它会牵动 UI 渲染发生变化，以及与之相关的副作用发生变化。在 `useState` 中，我们需要传入一个初始值，它会返回一个数组，第一个元素是当前的状态，第二个元素是一个函数，用于更新状态。

在这里，我们使用 `myUseState` 来实现一个简单的 `useState`，它接收一个初始值，返回一个数组，第一个元素是当前的状态，第二个元素是一个函数，用于更新状态。

```jsx {6}
function myUseState(initialValue){
  const getter = () => initialValue;
  const setter = (newValue) => {
      initialValue = newValue;
  }
  return [getter, setter];
}
```

export function myUseState (initialValue) {
  const getter = () => initialValue
  const setter = (newValue) => {
    console.log(newValue)
    initialValue = newValue
  }
  return [getter, setter]
}

export function Example2 () {
  const [count, setCount] = myUseState(0)
  return (
    <div className={'flex h-max'}>
      {count()}
      <button className={'ml-5 h-5 text-blue-500 flex items-center justify-center text-center text-2xl'} onClick={() => setCount(count() + 1)}>+</button>
    </div>
  )
}

使用示例如下，但是你会发现点击后，计数器的值并没有发生变化。这是因为我们还没实现更新状态的功能。但是你打开控制台，你会发现，当点击按钮时，`count` 的值确实发生了变化。

<Exb>
<Example2 />
</Exb>

<Callout type="info" emoji="ℹ️">
  复习：什么是闭包？闭包是指有权访问另一个函数作用域中的变量的函数。创建闭包的常见方式，就是在一个函数内部创建另一个函数。
</Callout>

这里我们定义了两个函数，`getter` 用于取值，`setter` 用于更新值，我们将这两个函数返回，这样就可以在外部使用 `getter` 和 `setter` 来获取和更新状态。这里实际上形成了一个闭包函数。注意这里与 React 有一点不同，我们返回的数组第一个元素并不是值，而是 getter ，这在后面会提到。

## `useEffect`

接下来我们实现 `useEffect`，它用于执行副作用，当依赖发生变化时，它会重新执行。他的行为是：

- useEffect 执行后，回调函数立刻执行。
- 依赖的自变量发生变化时，回调函数会重新执行。
- 不需要显式指明依赖。

如：

```jsx
const [count, setCount] = myUseState(0);

useEffect(() => {
  console.log('count changed'+count()); // 自动依赖 count
});

useEffect(() => {
  console.log('你好呀'); // 不依赖任何变量，因此 count 变化时不会执行
});

setCount(1);
```
实现的关键在于建立 myUseState 与 myUseState 之间的订阅发布关系。我们在 myUseState 中维护一个订阅者列表，来保存订阅这个 state 变化的 effect。effect 有下面的数据结构：

```jsx
const effect = {
  // effect 的回调函数
  execute,
  // 保存该 useEffect 依赖的 state 的对应 subs 的集合
  deps: new Set(),
}
```
这里让我们关注两个东西，一个是 `execute`，它是 effect 的回调函数，另一个是 `deps`，它是一个集合，用于保存该 effect 依赖的 state 的对应 subs 的集合。

`Set()` 是 ES6 中新增的数据结构，它类似于数组，但是成员的值都是唯一的，没有重复的值。它有以下的方法：

- `add(value)`：添加某个值，返回 Set 结构本身。
- `delete(value)`：删除某个值，返回一个布尔值，表示删除是否成功。
- `has(value)`：返回一个布尔值，表示该值是否为 Set 的成员。
- `clear()`：清除所有成员，没有返回值。
- ...

```js
let mySet = new Set();

mySet.add(1); // Set [ 1 ]
mySet.add(5); // Set [ 1, 5 ]
mySet.add(5); // Set [ 1, 5 ]
mySet.add("some text"); // Set [ 1, 5, "some text" ]
let o = {a: 1, b: 2};
mySet.add(o);

mySet.add({a: 1, b: 2}); // o 指向的是不同的对象，所以没问题

mySet.has(1); // true
mySet.has(3); // false
mySet.has(5);              // true
mySet.has(Math.sqrt(25));  // true
mySet.has("Some Text".toLowerCase()); // true
mySet.has(o); // true

mySet.size; // 5

mySet.delete(5);  // true，从 set 中移除 5
mySet.has(5);     // false, 5 已经被移除

mySet.size; // 4，刚刚移除一个值

console.log(mySet);
// logs Set(4) [ 1, "some text", {…}, {…} ] in Firefox
// logs Set(4) { 1, "some text", {…}, {…} } in Chrome
```

参考 [MDN Set🖱](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set)

通过遍历 state.subs 可以找到所有订阅这个 state 变化的 effect，然后将遍历 effect.deps 可以找到所有该 effect 依赖的 state，然后将 effect 添加到这些 state 的 subs 中。

```jsx
function myUseEffect (callback) {
  const execute = () => {
    // 重置依赖
    cleanup(effect);
    // 将当前 effect 推到栈顶
    effectStack.push(effect);
    try {
      // 执行回调函数
      callback();
    } finally {
      // 将当前 effect 从栈顶弹出
      effectStack.pop();
    }
  }
  const effect = {
    execute,
    deps: new Set(),
  }
  execute();
}
```
这里在执行回调函数前我们使用 cleanup 函数来重置依赖，这是因为当依赖发生变化时，我们需要将 effect 从原来的 state 的 subs 中移除，然后再添加到新的 state 的 subs 中。这里我们使用 `Set` 来保存依赖，因为 `Set` 中的成员是唯一的，所以我们可以通过 `Set` 来判断依赖是否发生变化。

```jsx filename="cleanup.js"
function cleanup (effect) {
  // 从该 effect 依赖的 state 的 subs 中移除该 effect
  for (const state of effect.deps) {
    state.subs.delete(effect);
  }
  // 清空该 effect 依赖的 state 的集合
  effect.deps.clear();
}
```
